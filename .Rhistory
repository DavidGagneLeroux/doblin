series.reshaped = merge(series.filtered_long,clusters_long,by.x = "rank",by.y = "rank", all = TRUE)
series.reshaped$variable = as.numeric(as.character(series.reshaped$variable))
## Group by cluster and keep only the clusters with at least n_members members
series.reshaped.1=series.reshaped %>%  dplyr::group_by(cluster,cutoff) %>% dplyr::filter(length(unique(ID)) >= n_members)
#cat("You might be ignoring dominant barcodes, please enter a minimum mean frequency that must be reached by at least one of the members for the cluster to be considered: ")
minimum_freq <-1e-03
series.reshaped.2 = series.reshaped %>%  dplyr::group_by(cluster,cutoff) %>% dplyr::filter(length(unique(ID)) < n_members) %>% mutate(mean_freq = mean(value)) %>% dplyr::filter(mean_freq >= minimum_freq)
series.reshaped.2$mean_freq = NULL
new.series.reshaped = rbind(series.reshaped.1, series.reshaped.2)
#################
#' @export
#' @rdname plotHCQuantification
melt_dist <- function(dist, order = NULL, dist_name = 'dist') {
if(!is.null(order)){
dist <- dist[order, order]
} else {
order <- row.names(dist)
}
diag(dist) <- NA
dist[upper.tri(dist)] <- NA
dist_df <- as.data.frame(dist)
dist_df$iso1 <- row.names(dist)
dist_df <- dist_df %>%
tidyr::gather_(key = "iso2", value = lazyeval::interp("dist_name", dist_name = as.name(dist_name)), order, na.rm = T)
return(dist_df)
}
#################
#' @export
#' @rdname plotClustersAndLoess
applyLOESS <- function(series_reshaped){
#series_reshaped = series.reshaped.2
#i=5
## Keep only the persistent barcodes
series_order=subset(series_reshaped,series_reshaped$variable==max(unique(series_reshaped$variable)))
series_order=series_order %>%
dplyr::group_by(cluster,cutoff) %>%
dplyr::summarise(average = mean(value)) %>% dplyr::ungroup() %>%
dplyr::group_by(cutoff) %>%
dplyr::arrange(desc(average), .by_group = TRUE)  %>% dplyr::mutate(cluster2=as.factor(row_number()))
series_order$cluster2=as.integer(as.character(series_order$cluster2))
series_reshaped=merge(series_reshaped,series_order,by=c("cluster","cutoff"))
series_reshaped$cluster=NULL
names(series_reshaped)[8]="cluster"
max.range = max(series_reshaped$variable)-min(series_reshaped$variable)
loess.range = (max.range*10)+1
## Get moving average of barcode frequencies for each cluster USING LOESS
xx <- seq(from=min(series_reshaped$variable), to=max(series_reshaped$variable),length.out = loess.range)
cluster.df=series_reshaped %>%  dplyr::group_by(cluster,cutoff) %>%
dplyr::summarise(model=predict(adjust_span(variable, value, span = 0.2),xx,se = FALSE))  %>%
dplyr::group_by(cluster,cutoff) %>% dplyr::mutate(time=xx)
return(cluster.df)
}
adjust_span <- function(x, y, span) {
# x = variable
# y = value
# span = 0.2
fit <- suppressWarnings(loess(log10(y+0.0000001) ~ x, span = span))
if (inherits(fit, "try-error")) {
# If loess() returns an error, try again with a smaller span
adjust_span(x, y, span/2)
} else if (inherits(fit, "warning")) {
# If loess() issues a warning, try again with a larger span
adjust_span(x, y, span + 0.1)
} else {
# If there are no errors or warnings, return the fitted object
return(fit)
}
}
clusters_dataframe = applyLOESS(new.series.reshaped)
clusters_dataframe$cluster=as.factor(as.integer(clusters_dataframe$cluster))
clusters_dataframe$cutoff=as.numeric(as.character(clusters_dataframe$cutoff))
cutoff=unique(clusters_dataframe$cutoff)
(!proxy::pr_DB$entry_exists("TSDistances")
)
tf = clusters_dataframe %>% split(.$cutoff)  %>%
purrr::map(~{
tidyr::spread(.x, key = cluster, value = model)
}) %>%  purrr::map(~{
proxy::dist(t(.x[c(-1,-2)]), method="TSDistances", distance="euclidean")
})
distance_pairwise=lapply(tf, function(x) melt_dist(as.matrix(x)))
distance_pairwise=do.call(rbind, (purrr::imap(distance_pairwise, ~mutate(.x, cutoff = .y))))
View(distance_pairwise)
smallest_distance<- distance_pairwise %>%
dplyr::mutate(cluster= as.numeric(iso1)) %>%
dplyr::group_by(cutoff) %>%
dplyr::mutate(cluster=max(cluster),id=paste(iso1,iso2 ,sep="_")) %>%
dplyr::summarise(dist_small=min(dist),cluster=max(cluster))
scale=max(smallest_distance$dist_small)/max(smallest_distance$cluster)
choose_threshold = ggplot(smallest_distance,aes(as.numeric(as.character(cutoff)),dist_small))+ geom_line(color="black", size=2.5) +
theme_Publication() + geom_line(aes(as.numeric(as.character(cutoff)), as.integer(as.character(cluster))*scale), size = 2, color = "darkblue") +
scale_y_continuous(sec.axis = sec_axis(~./scale,name="Cluster number")) + scale_x_reverse() +xlab("Threshold")
ggsave(choose_threshold,filename =  paste(output_directory,sample_name, "_threshold_selection", ".png",sep=""),width = 9,height = 8, device =cairo_ps())
breaks <- list()
for(i in 1:length(input_data)){
breaks <-append(breaks, list(sort(c(unique(input_data[[i]]$Time)))))
}
View(smallest_distance)
selected_threshold <-0.35
readr::write_csv(smallest_distance,file = paste(output_directory, sample_name, "_threshold_selection.csv",sep=""),col_names = TRUE)
selected_clusters = get_clonal_lineage_clusters(filtered_dataframes[[1]], cohort_names[[1]], linkage, clustering, covariance, selected_threshold)
#' Plot the log10-transformed barcode frequencies and the moving averages (LOESS)
#'
#' This file contains multiple functions. The main function is: plot_clusters_and_loess()
#' and it uses plotClusterLog10() and applyLOESS(). plot_clusters_and_loess() starts in
#' the same way as plotHCQuantification(), but without a cutoff column. In plot_clusters_and_loess(),
#' we plot the log10-transformed barcode frequencies contained in all selected clusters,
#' we compute a moving average per cluster and group them in a plot. We also write the files associated with
#' those two plots.
#'
#' @name plotClustersAndLoess
#' @param series.filtered a dataframe filtered by filterData()
#' @param selected.clusters  A dataframe containing the clusters from a hierarchical clustering
#'  for a specific threshold
#' @param sample_name a character string indicating the sample's name
#' @param effective.breaks a list containing the breaks for the plots
#' @param n_members an integer indicating the minimum number of members per cluster
#' @import dplyr
#' @import ggplot2
#' @export plot_clusters_and_loess
cluster.colors=c("#3cb44b","#4363d8","#e6194B","#e8ca00","#911eb4","#f58231","#22766dff","#42d4f4","#f032e6","#9A6324",
"#2F4C39", "#1D3F6E","#94170f","#665679","#F17829","#97A69C","#606EA9","#A9606E","#A99060","#F8F1AE",
"#bcf60c", "#fabebe", "#008080", "#e6beff", "#9a6324", "#fffac8")
plot_clusters_and_loess <- function(series.filtered, selected.clusters, sample_name, effective.breaks, n_members){
#series.filtered = filtered_dataframes[[1]]
#sample_name = "X1r1"
#selected.clusters=selected_clusters
#effective.breaks = breaks[[1]]
#n_members = 8
effective.labels = as.character(effective.breaks)
effective.limits = c(min(effective.breaks), max(effective.breaks))
colnames(selected.clusters)=c("cluster")
nRank = nrow(selected.clusters)
selected.clusters$rank = seq(1:nRank)
series.filtered$points = NULL
series.filtered$rank=seq(1:nRank)
grouped.clusters = merge(series.filtered,selected.clusters,by.x = "rank",by.y = "rank")
## series.reshaped is a dataframe where "variable" represents the time-point (1-18) and value
## represents the barcode frequencies
series.reshaped = reshape2::melt(grouped.clusters,id.vars = c('ID','cluster','rank','mean'))
series.reshaped$variable = as.numeric(as.character(series.reshaped$variable))
## Group by cluster and keep only the clusters with at least n_members members
series.reshaped.1=series.reshaped %>%  dplyr::group_by(cluster,cutoff) %>% dplyr::filter(length(unique(ID)) >= n_members)
## To avoid ignoring the dominant barcodes, which might be in smaller clusters, we add a second criteria:
if(nrow(series.reshaped.1) != nrow(series.reshaped)){
#cat("You might be ignoring dominant barcodes, please enter a minimum mean frequency that must be reached by at least one of the members for the cluster to be considered: ")
minimum_freq <-1e-03
#minimum_freq <- as.numeric(readLines("stdin", n=1))
series.reshaped.2 = series.reshaped %>%  dplyr::group_by(cluster,cutoff) %>% dplyr::filter(length(unique(ID)) < n_members) %>% mutate(mean_freq = mean(value)) %>% dplyr::filter(mean_freq >= minimum_freq)
series.reshaped.2$mean_freq = NULL
series.reshaped = rbind(series.reshaped.1, series.reshaped.2)
}
clusters_dataframe = applyLOESS(series.reshaped, effective.breaks, sample_name)
## Write series.reshape
readr::write_csv(series.reshaped,file = paste(output_directory, sample_name, "_clustered_series_log10.csv",sep=""),col_names = TRUE)
rm(series.reshaped)
## loesss
#TODO: considérer plusieurs cluster.df
clusters_dataframe$cluster=paste("C",clusters_dataframe$cluster,sep="")
clusters_dataframe$time=clusters_dataframe$time*10
clusters.loess <- tidyr::spread(clusters_dataframe, cluster, value)
# plot loess
loess.plot = ggplot(clusters_dataframe) + geom_line(aes(time/10,value,group=cluster,color=cluster),size=1) + scale_x_continuous(limits = effective.limits) +
theme_Publication() + scale_color_manual(values = cluster.colors,name="cluster") + ylab("fit") + xlab("Time") + ylim(min(clusters_dataframe$value),1)
ggsave(loess.plot,filename = paste(output_directory, sample_name, "_loess_clusters_log10.jpeg", sep=""),width = 8.25,height = 6,device = "jpeg")
# write loess file
readr::write_csv(clusters.loess,file = paste(output_directory, sample_name, "_clustered_loess_log10.csv",sep=""),col_names = TRUE)
}
#################
#' @export
#' @rdname plotClustersAndLoess
# plot clusters
plotClusterLog10 <- function(df,cluster,sample,color,tf, effective.breaks){
effective.labels = as.character(effective.breaks)
effective.limits = c(min(effective.breaks), max(effective.breaks))
p = ggplot(df,aes(x=variable,y=log10(value+0.0000001))) +
geom_line(aes(group=ID),color=color,alpha=0.4) + theme_Publication(base_size = 18) +
ylim(min(log10(df$value + 0.0000001)),0) +
labs(x = "Time",y="log10(Barcode frequency)") + guides(color = FALSE) +
scale_x_continuous(limits = effective.limits) +
coord_cartesian(expand = FALSE) + geom_line(data=tf,aes(time,value),color="black") +
annotate("text", y=-0.75, x = 3,label=paste("n",length(unique(df$ID)),sep=" = "),hjust=0,size=5) +
ggtitle(paste("Cluster",cluster,sep=" "))
# must plot to extract fit
ggsave(filename = paste(output_directory, sample, "_cluster", cluster, "_log10.jpeg", sep=""),width = 5.5,height = 4,device = "jpeg")
return(p)
}
#################
#' @export
#' @rdname plotClustersAndLoess
apply_LOESS <- function(series_reshaped, effective.breaks, sample_name){
#series_reshaped <- series.reshaped.2
## Keep only the persistent barcodes
## series_order only contains the data regarding the last generation/time-point
series_order=subset(series_reshaped,series_reshaped$variable==max(unique(series_reshaped$variable)))
series_order=series_order %>%
dplyr::group_by(cluster) %>%
dplyr::summarise(average = mean(value))
series_order=series_order[order(series_order$average,decreasing = TRUE), ]
series_order$cluster_ranked=as.numeric(rownames(series_order))
series_reshaped=merge(series_reshaped,series_order,by="cluster")
series_reshaped$cluster=NULL
names(series_reshaped)[7]="cluster"
clusters.ranked=series_order$cluster_ranked
max.range = max(series_reshaped$variable)-min(series_reshaped$variable)
loess.range = (max.range*10)+1
## Get moving average of barcode frequencies for each cluster USING LOESS
xx <- seq(from=min(series_reshaped$variable), to=max(series_reshaped$variable),length.out = loess.range)
cluster.df=series_reshaped %>%  dplyr::group_by(cluster) %>%
dplyr::summarise(value=predict(adjust_span(variable, value, span = 0.2),xx,se = FALSE))  %>%
dplyr::group_by(cluster) %>% dplyr::mutate(time=xx)
## Plot log10-transformed barcode frequencies
plotList = list()
for(i in seq_along(unique(series_reshaped$cluster))){
l = plotClusterLog10(series_reshaped[series_reshaped$cluster==clusters.ranked[i],], clusters.ranked[i], sample_name, cluster.colors[i],cluster.df[cluster.df$cluster==clusters.ranked[i],], effective.breaks)
plotList[[i]]=l
}
#top10.log =cowplot::plot_grid(plotlist=plotList, align = "hv",axis="tblr", nrow=ceiling(length(unique(series_reshaped$cluster))))
#ggsave(top10.log,filename = paste(output_directory, sample_name, "_clusters_log10_", as.character(clusters.ranked[i]) ,".jpeg", sep=""),width = 18,height=7.5*length(unique(series_reshaped$cluster))/5, device="jpeg")
return(cluster.df)
}
adjust_span <- function(x, y, span) {
# x = variable
# y = value
# span = 0.2
fit <- suppressWarnings(loess(log10(y+0.0000001) ~ x, span = span))
if (inherits(fit, "try-error")) {
# If loess() returns an error, try again with a smaller span
adjust_span(x, y, span/2)
} else if (inherits(fit, "warning")) {
# If loess() issues a warning, try again with a larger span
adjust_span(x, y, span + 0.1)
} else {
# If there are no errors or warnings, return the fitted object
return(fit)
}
}
plot_clusters_and_loess(filtered_dataframes[[1]], selected_clusters, cohort_names[[1]], breaks[[1]], min_members)
#' Plot the log10-transformed barcode frequencies and the moving averages (LOESS)
#'
#' This file contains multiple functions. The main function is: plot_clusters_and_loess()
#' and it uses plotClusterLog10() and applyLOESS(). plot_clusters_and_loess() starts in
#' the same way as plotHCQuantification(), but without a cutoff column. In plot_clusters_and_loess(),
#' we plot the log10-transformed barcode frequencies contained in all selected clusters,
#' we compute a moving average per cluster and group them in a plot. We also write the files associated with
#' those two plots.
#'
#' @name plotClustersAndLoess
#' @param series.filtered a dataframe filtered by filterData()
#' @param selected.clusters  A dataframe containing the clusters from a hierarchical clustering
#'  for a specific threshold
#' @param sample_name a character string indicating the sample's name
#' @param effective.breaks a list containing the breaks for the plots
#' @param n_members an integer indicating the minimum number of members per cluster
#' @import dplyr
#' @import ggplot2
#' @export plot_clusters_and_loess
cluster.colors=c("#3cb44b","#4363d8","#e6194B","#e8ca00","#911eb4","#f58231","#22766dff","#42d4f4","#f032e6","#9A6324",
"#2F4C39", "#1D3F6E","#94170f","#665679","#F17829","#97A69C","#606EA9","#A9606E","#A99060","#F8F1AE",
"#bcf60c", "#fabebe", "#008080", "#e6beff", "#9a6324", "#fffac8")
plot_clusters_and_loess <- function(series.filtered, selected.clusters, sample_name, effective.breaks, n_members){
#series.filtered = filtered_dataframes[[1]]
#sample_name = "X1r1"
#selected.clusters=selected_clusters
#effective.breaks = breaks[[1]]
#n_members = 8
effective.labels = as.character(effective.breaks)
effective.limits = c(min(effective.breaks), max(effective.breaks))
colnames(selected.clusters)=c("cluster")
nRank = nrow(selected.clusters)
selected.clusters$rank = seq(1:nRank)
series.filtered$points = NULL
series.filtered$rank=seq(1:nRank)
grouped.clusters = merge(series.filtered,selected.clusters,by.x = "rank",by.y = "rank")
## series.reshaped is a dataframe where "variable" represents the time-point (1-18) and value
## represents the barcode frequencies
series.reshaped = reshape2::melt(grouped.clusters,id.vars = c('ID','cluster','rank','mean'))
series.reshaped$variable = as.numeric(as.character(series.reshaped$variable))
## Group by cluster and keep only the clusters with at least n_members members
series.reshaped.1=series.reshaped %>%  dplyr::group_by(cluster) %>% dplyr::filter(length(unique(ID)) >= n_members)
## To avoid ignoring the dominant barcodes, which might be in smaller clusters, we add a second criteria:
if(nrow(series.reshaped.1) != nrow(series.reshaped)){
#cat("You might be ignoring dominant barcodes, please enter a minimum mean frequency that must be reached by at least one of the members for the cluster to be considered: ")
minimum_freq <-1e-03
#minimum_freq <- as.numeric(readLines("stdin", n=1))
series.reshaped.2 = series.reshaped %>%  dplyr::group_by(cluster) %>% dplyr::filter(length(unique(ID)) < n_members) %>% mutate(mean_freq = mean(value)) %>% dplyr::filter(mean_freq >= minimum_freq)
series.reshaped.2$mean_freq = NULL
series.reshaped = rbind(series.reshaped.1, series.reshaped.2)
}
clusters_dataframe = applyLOESS(series.reshaped, effective.breaks, sample_name)
## Write series.reshape
readr::write_csv(series.reshaped,file = paste(output_directory, sample_name, "_clustered_series_log10.csv",sep=""),col_names = TRUE)
rm(series.reshaped)
## loesss
#TODO: considérer plusieurs cluster.df
clusters_dataframe$cluster=paste("C",clusters_dataframe$cluster,sep="")
clusters_dataframe$time=clusters_dataframe$time*10
clusters.loess <- tidyr::spread(clusters_dataframe, cluster, value)
# plot loess
loess.plot = ggplot(clusters_dataframe) + geom_line(aes(time/10,value,group=cluster,color=cluster),size=1) + scale_x_continuous(limits = effective.limits) +
theme_Publication() + scale_color_manual(values = cluster.colors,name="cluster") + ylab("fit") + xlab("Time") + ylim(min(clusters_dataframe$value),1)
ggsave(loess.plot,filename = paste(output_directory, sample_name, "_loess_clusters_log10.jpeg", sep=""),width = 8.25,height = 6,device = "jpeg")
# write loess file
readr::write_csv(clusters.loess,file = paste(output_directory, sample_name, "_clustered_loess_log10.csv",sep=""),col_names = TRUE)
}
#################
#' @export
#' @rdname plotClustersAndLoess
# plot clusters
plotClusterLog10 <- function(df,cluster,sample,color,tf, effective.breaks){
effective.labels = as.character(effective.breaks)
effective.limits = c(min(effective.breaks), max(effective.breaks))
p = ggplot(df,aes(x=variable,y=log10(value+0.0000001))) +
geom_line(aes(group=ID),color=color,alpha=0.4) + theme_Publication(base_size = 18) +
ylim(min(log10(df$value + 0.0000001)),0) +
labs(x = "Time",y="log10(Barcode frequency)") + guides(color = FALSE) +
scale_x_continuous(limits = effective.limits) +
coord_cartesian(expand = FALSE) + geom_line(data=tf,aes(time,value),color="black") +
annotate("text", y=-0.75, x = 3,label=paste("n",length(unique(df$ID)),sep=" = "),hjust=0,size=5) +
ggtitle(paste("Cluster",cluster,sep=" "))
# must plot to extract fit
ggsave(filename = paste(output_directory, sample, "_cluster", cluster, "_log10.jpeg", sep=""),width = 5.5,height = 4,device = "jpeg")
return(p)
}
#################
#' @export
#' @rdname plotClustersAndLoess
apply_LOESS <- function(series_reshaped, effective.breaks, sample_name){
#series_reshaped <- series.reshaped.2
## Keep only the persistent barcodes
## series_order only contains the data regarding the last generation/time-point
series_order=subset(series_reshaped,series_reshaped$variable==max(unique(series_reshaped$variable)))
series_order=series_order %>%
dplyr::group_by(cluster) %>%
dplyr::summarise(average = mean(value))
series_order=series_order[order(series_order$average,decreasing = TRUE), ]
series_order$cluster_ranked=as.numeric(rownames(series_order))
series_reshaped=merge(series_reshaped,series_order,by="cluster")
series_reshaped$cluster=NULL
names(series_reshaped)[7]="cluster"
clusters.ranked=series_order$cluster_ranked
max.range = max(series_reshaped$variable)-min(series_reshaped$variable)
loess.range = (max.range*10)+1
## Get moving average of barcode frequencies for each cluster USING LOESS
xx <- seq(from=min(series_reshaped$variable), to=max(series_reshaped$variable),length.out = loess.range)
cluster.df=series_reshaped %>%  dplyr::group_by(cluster) %>%
dplyr::summarise(value=predict(adjust_span(variable, value, span = 0.2),xx,se = FALSE))  %>%
dplyr::group_by(cluster) %>% dplyr::mutate(time=xx)
## Plot log10-transformed barcode frequencies
plotList = list()
for(i in seq_along(unique(series_reshaped$cluster))){
l = plotClusterLog10(series_reshaped[series_reshaped$cluster==clusters.ranked[i],], clusters.ranked[i], sample_name, cluster.colors[i],cluster.df[cluster.df$cluster==clusters.ranked[i],], effective.breaks)
plotList[[i]]=l
}
#top10.log =cowplot::plot_grid(plotlist=plotList, align = "hv",axis="tblr", nrow=ceiling(length(unique(series_reshaped$cluster))))
#ggsave(top10.log,filename = paste(output_directory, sample_name, "_clusters_log10_", as.character(clusters.ranked[i]) ,".jpeg", sep=""),width = 18,height=7.5*length(unique(series_reshaped$cluster))/5, device="jpeg")
return(cluster.df)
}
adjust_span <- function(x, y, span) {
# x = variable
# y = value
# span = 0.2
fit <- suppressWarnings(loess(log10(y+0.0000001) ~ x, span = span))
if (inherits(fit, "try-error")) {
# If loess() returns an error, try again with a smaller span
adjust_span(x, y, span/2)
} else if (inherits(fit, "warning")) {
# If loess() issues a warning, try again with a larger span
adjust_span(x, y, span + 0.1)
} else {
# If there are no errors or warnings, return the fitted object
return(fit)
}
}
plot_clusters_and_loess(filtered_dataframes[[1]], selected_clusters, cohort_names[[1]], breaks[[1]], min_members)
#' Plot the log10-transformed barcode frequencies and the moving averages (LOESS)
#'
#' This file contains multiple functions. The main function is: plot_clusters_and_loess()
#' and it uses plotClusterLog10() and applyLOESS(). plot_clusters_and_loess() starts in
#' the same way as plotHCQuantification(), but without a cutoff column. In plot_clusters_and_loess(),
#' we plot the log10-transformed barcode frequencies contained in all selected clusters,
#' we compute a moving average per cluster and group them in a plot. We also write the files associated with
#' those two plots.
#'
#' @name plotClustersAndLoess
#' @param series.filtered a dataframe filtered by filterData()
#' @param selected.clusters  A dataframe containing the clusters from a hierarchical clustering
#'  for a specific threshold
#' @param sample_name a character string indicating the sample's name
#' @param effective.breaks a list containing the breaks for the plots
#' @param n_members an integer indicating the minimum number of members per cluster
#' @import dplyr
#' @import ggplot2
#' @export plot_clusters_and_loess
cluster.colors=c("#3cb44b","#4363d8","#e6194B","#e8ca00","#911eb4","#f58231","#22766dff","#42d4f4","#f032e6","#9A6324",
"#2F4C39", "#1D3F6E","#94170f","#665679","#F17829","#97A69C","#606EA9","#A9606E","#A99060","#F8F1AE",
"#bcf60c", "#fabebe", "#008080", "#e6beff", "#9a6324", "#fffac8")
plot_clusters_and_loess <- function(series.filtered, selected.clusters, sample_name, effective.breaks, n_members){
#series.filtered = filtered_dataframes[[1]]
#sample_name = "X1r1"
#selected.clusters=selected_clusters
#effective.breaks = breaks[[1]]
#n_members = 8
effective.labels = as.character(effective.breaks)
effective.limits = c(min(effective.breaks), max(effective.breaks))
colnames(selected.clusters)=c("cluster")
nRank = nrow(selected.clusters)
selected.clusters$rank = seq(1:nRank)
series.filtered$points = NULL
series.filtered$rank=seq(1:nRank)
grouped.clusters = merge(series.filtered,selected.clusters,by.x = "rank",by.y = "rank")
## series.reshaped is a dataframe where "variable" represents the time-point (1-18) and value
## represents the barcode frequencies
series.reshaped = reshape2::melt(grouped.clusters,id.vars = c('ID','cluster','rank','mean'))
series.reshaped$variable = as.numeric(as.character(series.reshaped$variable))
## Group by cluster and keep only the clusters with at least n_members members
series.reshaped.1=series.reshaped %>%  dplyr::group_by(cluster) %>% dplyr::filter(length(unique(ID)) >= n_members)
## To avoid ignoring the dominant barcodes, which might be in smaller clusters, we add a second criteria:
if(nrow(series.reshaped.1) != nrow(series.reshaped)){
#cat("You might be ignoring dominant barcodes, please enter a minimum mean frequency that must be reached by at least one of the members for the cluster to be considered: ")
minimum_freq <-1e-03
#minimum_freq <- as.numeric(readLines("stdin", n=1))
series.reshaped.2 = series.reshaped %>%  dplyr::group_by(cluster) %>% dplyr::filter(length(unique(ID)) < n_members) %>% mutate(mean_freq = mean(value)) %>% dplyr::filter(mean_freq >= minimum_freq)
series.reshaped.2$mean_freq = NULL
series.reshaped = rbind(series.reshaped.1, series.reshaped.2)
}
clusters_dataframe = apply_LOESS(series.reshaped, effective.breaks, sample_name)
## Write series.reshape
readr::write_csv(series.reshaped,file = paste(output_directory, sample_name, "_clustered_series_log10.csv",sep=""),col_names = TRUE)
rm(series.reshaped)
## loesss
#TODO: considérer plusieurs cluster.df
clusters_dataframe$cluster=paste("C",clusters_dataframe$cluster,sep="")
clusters_dataframe$time=clusters_dataframe$time*10
clusters.loess <- tidyr::spread(clusters_dataframe, cluster, value)
# plot loess
loess.plot = ggplot(clusters_dataframe) + geom_line(aes(time/10,value,group=cluster,color=cluster),size=1) + scale_x_continuous(limits = effective.limits) +
theme_Publication() + scale_color_manual(values = cluster.colors,name="cluster") + ylab("fit") + xlab("Time") + ylim(min(clusters_dataframe$value),1)
ggsave(loess.plot,filename = paste(output_directory, sample_name, "_loess_clusters_log10.jpeg", sep=""),width = 8.25,height = 6,device = "jpeg")
# write loess file
readr::write_csv(clusters.loess,file = paste(output_directory, sample_name, "_clustered_loess_log10.csv",sep=""),col_names = TRUE)
}
#################
#' @export
#' @rdname plotClustersAndLoess
# plot clusters
plotClusterLog10 <- function(df,cluster,sample,color,tf, effective.breaks){
effective.labels = as.character(effective.breaks)
effective.limits = c(min(effective.breaks), max(effective.breaks))
p = ggplot(df,aes(x=variable,y=log10(value+0.0000001))) +
geom_line(aes(group=ID),color=color,alpha=0.4) + theme_Publication(base_size = 18) +
ylim(min(log10(df$value + 0.0000001)),0) +
labs(x = "Time",y="log10(Barcode frequency)") + guides(color = FALSE) +
scale_x_continuous(limits = effective.limits) +
coord_cartesian(expand = FALSE) + geom_line(data=tf,aes(time,value),color="black") +
annotate("text", y=-0.75, x = 3,label=paste("n",length(unique(df$ID)),sep=" = "),hjust=0,size=5) +
ggtitle(paste("Cluster",cluster,sep=" "))
# must plot to extract fit
ggsave(filename = paste(output_directory, sample, "_cluster", cluster, "_log10.jpeg", sep=""),width = 5.5,height = 4,device = "jpeg")
return(p)
}
#################
#' @export
#' @rdname plotClustersAndLoess
apply_LOESS <- function(series_reshaped, effective.breaks, sample_name){
#series_reshaped <- series.reshaped.2
## Keep only the persistent barcodes
## series_order only contains the data regarding the last generation/time-point
series_order=subset(series_reshaped,series_reshaped$variable==max(unique(series_reshaped$variable)))
series_order=series_order %>%
dplyr::group_by(cluster) %>%
dplyr::summarise(average = mean(value))
series_order=series_order[order(series_order$average,decreasing = TRUE), ]
series_order$cluster_ranked=as.numeric(rownames(series_order))
series_reshaped=merge(series_reshaped,series_order,by="cluster")
series_reshaped$cluster=NULL
names(series_reshaped)[7]="cluster"
clusters.ranked=series_order$cluster_ranked
max.range = max(series_reshaped$variable)-min(series_reshaped$variable)
loess.range = (max.range*10)+1
## Get moving average of barcode frequencies for each cluster USING LOESS
xx <- seq(from=min(series_reshaped$variable), to=max(series_reshaped$variable),length.out = loess.range)
cluster.df=series_reshaped %>%  dplyr::group_by(cluster) %>%
dplyr::summarise(value=predict(adjust_span(variable, value, span = 0.2),xx,se = FALSE))  %>%
dplyr::group_by(cluster) %>% dplyr::mutate(time=xx)
## Plot log10-transformed barcode frequencies
plotList = list()
for(i in seq_along(unique(series_reshaped$cluster))){
l = plotClusterLog10(series_reshaped[series_reshaped$cluster==clusters.ranked[i],], clusters.ranked[i], sample_name, cluster.colors[i],cluster.df[cluster.df$cluster==clusters.ranked[i],], effective.breaks)
plotList[[i]]=l
}
#top10.log =cowplot::plot_grid(plotlist=plotList, align = "hv",axis="tblr", nrow=ceiling(length(unique(series_reshaped$cluster))))
#ggsave(top10.log,filename = paste(output_directory, sample_name, "_clusters_log10_", as.character(clusters.ranked[i]) ,".jpeg", sep=""),width = 18,height=7.5*length(unique(series_reshaped$cluster))/5, device="jpeg")
return(cluster.df)
}
adjust_span <- function(x, y, span) {
# x = variable
# y = value
# span = 0.2
fit <- suppressWarnings(loess(log10(y+0.0000001) ~ x, span = span))
if (inherits(fit, "try-error")) {
# If loess() returns an error, try again with a smaller span
adjust_span(x, y, span/2)
} else if (inherits(fit, "warning")) {
# If loess() issues a warning, try again with a larger span
adjust_span(x, y, span + 0.1)
} else {
# If there are no errors or warnings, return the fitted object
return(fit)
}
}
plot_clusters_and_loess(filtered_dataframes[[1]], selected_clusters, cohort_names[[1]], breaks[[1]], min_members)
